# -*- coding: utf-8 -*-
import os
import json
import re
import copy
import collections

custom_paths = json.load(open(os.path.join(request.folder,"private","static_open_api.json"),"rb"))

autogenerated_base = "/%s/%s" % (request.controller,"api")

auth_bearer = {
        "bearerAuth":{
        "type": "http",
        "name": "Authorization",
        "in": "header",
        "description":"Requests should pass an Authorization: Bearer TOKEN_VALUEBASE_64 header"
        }
    }

swaggerBasics = {
    "openapi": "3.0.0",
    "servers": [{"url":"http://" + request.env.HTTP_HOST+  "/%s" % (request.application)} ],
    "info": {
        "description": configuration.get("app.description"),
        "version": configuration.get("app.version"),
        "title": configuration.get("app.name"),
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "email": configuration.get("app.author")
        },
        "license": {
            "name":""
        }
    },
 #   "host": request.env.HTTP_HOST,
 #   "basePath": "/%s/%s" % (request.application,request.controller),
    "tags": [],
    #"schemes": ["https","http"],
  #  "securityDefinitions":auth_bearer,
    "components":{"securitySchemes":{"bearerAuth":{"type":"http","scheme":"bearer"}}},
    "security" : [{"bearerAuth":[]}]
}

def minimal_field_def(field_def):
    result = {}
    result["type"] = field_def["type"]
    result["label"] = field_def["label"]
    result["fieldname"] = field_def["fieldname"]
    result["required"] = field_def["required"]
    result["writable"] = field_def["writable"]
    result["readable"] = field_def["readable"]

    return result

def minimal_table_def(table_def):

    result = {}
    fields = []

    result["tablename"] = table_def["tablename"]

    for field in table_def["fields"]:
        field_def = minimal_field_def(field)
        fields.append(field_def)

    result["fields"] = fields

    return result
    
def dal_table_to_swagger_properties(dal_table):
    fields = dal_table["fields"]
    swagger_properties = {}
    for field in fields:
        _property = {}
        fieldname = field.get("fieldname")
        dalFieldType = field.get("type")
        swaggerFieldType = dalFieldType

        if dalFieldType == "id":
            swaggerFieldType = "integer"

        if dalFieldType == "password":
            swaggerFieldType = "string"

        if dalFieldType == "text":
            swaggerFieldType = "string"

        _property["type"] = swaggerFieldType

        if dalFieldType == "datetime":
            _property = {
                "type": "string",
                "format": "date-time"
            }

        if dalFieldType == "upload":
            _property = {
                "type": "string",
                "format": "base64"
            }

        if dalFieldType.startswith("reference "):
            referenceEntity = dalFieldType.split("reference ")[1]
            _property = {"type": "string"}

        if dalFieldType.startswith("list:"):
            listType = dalFieldType.split("list:")[1]
            if listType.startswith("reference"):
                referenceEntity = dalFieldType.split("reference ")[1]
                listItems = {
                        "xml": {
                            "name": referenceEntity
                        },
                        "$ref": "#/components/schemas/%s" % referenceEntity
                    }
            else:
                listItems = {
                        "xml": {
                            "name": "itemLabel"
                        },
                        "type": "string"
                    }
            
            _property = {
                "type":"array",
                "xml": {
                    "wrapped": True
                },
                "items":listItems
            }

        _property["readable"] = field.get("readable")
        _property["writable"] = field.get("writable")

        swagger_properties[fieldname] = _property
    return swagger_properties

def dal_definitions_to_swagger_definitions(dal_definitions):

    swagger_definitions = {}

    entities = dal_definitions.keys()

    swagger_definitions = dict.fromkeys(entities)

    for key, definition in swagger_definitions.iteritems():
        dal_table = dal_definitions[key]
        properties = dal_table_to_swagger_properties(dal_table)
        definition = {
            "type":"object",
            "xml":{"name":key},
            "properties":properties
        }
        swagger_definitions[key] = definition

    return swagger_definitions


def swaggerDefinitions_to_tags(items):
    return [{
        "name": k, 
        "description": "Everything about %s" % k, 
        "externalDocs": {"description": "Swagger","url": "http://swagger.io"}
        } for k in items]


def dal_db_min_definitions(db):
    min_definitions = {}

    for t in db.tables:
        table = db[t]
        for field in table["fields"]:
            table[field].requires = []
            table[field].represent = None
        table_def = table.as_dict()
        min_definitions[t] = minimal_table_def(table_def)
        
    return min_definitions

def dal_db_to_swagger_definitions(db):
    min_definitions = dal_db_min_definitions(db)
    swaggerDefinitions = dal_definitions_to_swagger_definitions(min_definitions)    

    return swaggerDefinitions

def dal_to_swagger(db):
    # constructs a swagger schema from a pyDAL db instance

    result = swaggerBasics

    swaggerDefinitions = dal_db_to_swagger_definitions(db)
    swaggerTags = swaggerDefinitions_to_tags(sorted(swaggerDefinitions.keys()))

    schemas = {"schemas":swaggerDefinitions}
    result["components"].update(schemas)
    #result["tags"] = swaggerTags

    return result


def db_patterns_to_swagger_paths(db):
    patterns = 'auto'
    args = ["patterns"]
    parser = db.parse_as_rest(patterns, args, {})

    pathnames = parser.response

    paths = collections.OrderedDict()

    swaggerDefinitions = dal_db_to_swagger_definitions(db)

    def convertPathParam(pathDictParam):
        values = pathDictParam.split(".")
        newValue = "".join([v[0].upper() + v[1:] for v in values]).replace("]","").replace(":","")
        return newValue

    def get_returned_entity(p):
        return p.split("/")[1].split("[")[0]

    for pathname in pathnames:

        regex_dict = r"\{(\w+.\w*[.\w*]*)\}*"
        regex_list = r"\[(\w+.\w*[.\w*]*)\]*"
        #regex_field = r"(:field)*"
        regex_field = r"(\:field*)"

        pathDictParams = re.findall(regex_dict,pathname)
        pathListParams = re.findall(regex_list,pathname)
        pathFieldParams = re.findall(regex_field,pathname)

        original_pathname = pathname[:]

        replacements = {}
        parameters = []

        for pathDictParam in pathDictParams:
            key = "{%s}" % pathDictParam
            converted_value = convertPathParam(pathDictParam)
            parameters.append({"name":converted_value,"in":"path","schema":{"type":"string"}, "required":True})
            replacements[key] = "{%s}" % converted_value

        for pathListParam in pathListParams:
            key = "[%s" % pathListParam
            converted_value = convertPathParam(pathListParam)
            entityKey = get_returned_entity(original_pathname)
            entityDef = swaggerDefinitions.get(entityKey)
            requestBody = {
                "required":True,
                "content":{
                    "application/json":{
                        "schema":{
                           "$ref":"#/components/schemas/%s"% entityKey
                        }
                    }
                }
            }

            replacements[key] = ""

        for pathFieldParam in pathFieldParams:
            key = pathFieldParam
            converted_value = convertPathParam(pathFieldParam)
            entityKey = get_returned_entity(original_pathname)
            entityDef = swaggerDefinitions.get(entityKey)
            fieldNames = entityDef["properties"].keys()

            param = {
                "name":converted_value,
                "in":"path",
                "required":True,
                "schema": 
                    {
                        "type":"string"
                    }
                }

            parameters.append(param)
            replacements[key] = "{%s}" % converted_value

        for k,v in replacements.iteritems():
            pathname = pathname.replace(k,v)

        returned_entity = get_returned_entity(original_pathname)

        

        c = len(pathListParams) == 1 and returned_entity.upper() == convertPathParam(pathListParams[0]).upper()

        if c:
            methods = ["post","put","delete"]
            pathContent = {
                "summary":original_pathname,
                "requestBody":requestBody,
                "responses": {
                                "200": {
                                    "content":{
                                        "application/json": {
                                        "schema": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/components/schemas/%s" % returned_entity
                                                }
                                            }
                                        }
                                    },
                                    "description":""
                                },
                                "400": {
                                    "description": "Invalid request"
                                }
                            }
            }

        else:
            methods = ["get"]
            pathContent = {
                        #  "tags" : [returned_entity],
                            "parameters": parameters,
                            "summary":original_pathname,
                            "responses": {
                                "200": {
                                    "content":{
                                        "application/json": {
                                        "schema": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/components/schemas/%s" % returned_entity
                                                }
                                            }
                                        }
                                    },
                                    "description":""
                                },
                                "400": {
                                    "description": "Invalid request"
                                }
                            },
                        }

        path = collections.OrderedDict()

        for method in methods:
            PathContent = copy.deepcopy(pathContent)
            op_path = pathname.replace("{","").replace("}","").replace("/","")
            operationId =  '%s%s' % (method,op_path)
            PathContent["operationId"] = operationId
            path[method] = PathContent
            
        p = autogenerated_base + pathname
        paths[p] = path

    return paths



def swagger():

    result = dal_to_swagger(db)

    updatedSchemas = collections.OrderedDict()

    for table_name,table_def in result["components"]["schemas"].iteritems():
        for key,_property in table_def["properties"].iteritems():
            if "writable" in _property.keys():
                _property.pop("writable")
            if "readable" in _property.keys():
                _property.pop("readable")
            table_def["properties"][key] = _property

        updatedSchemas[table_name] = table_def
            
    result["components"]["schemas"] = updatedSchemas

    result["paths"] = db_patterns_to_swagger_paths(db)

    result["paths"].update(custom_paths)

    return response.json(result)

def formSchema():
    table_name = request.args(0)
    swag = dal_to_swagger(db)
    result = swag["components"]["schemas"][table_name]

    _writable_props = {}

    for key,_property in result["properties"].iteritems():
        if _property.get("writable") == True:
            _writable_props[key] = _property

    result["properties"] = _writable_props
    result["components"] = copy.deepcopy(swag["components"])

    return response.json(result)


@request.restful()
def api():

    response.view = 'generic.json'

    def GET(*args, **vars):
        patterns = 'auto'
        parser = db.parse_as_rest(patterns, args, vars)
        if parser.status == 200:
            return dict(message=parser.response)
        else:
            raise HTTP(parser.status, parser.error)

    def POST(table_name, **vars):
        return dict(db[table_name].validate_and_insert(**vars))

    def PUT(*args, **vars):
        if args and len(args) > 0:
            table_name = args[0]
            _id_record = vars.get("id")
            query = db[table_name].id == _id_record
            return dict(db(query).validate_and_update(**vars))

    def DELETE(*args, **vars):
        print "DELETE",args,vars
        if args and len(args) > 0:
            table_name = args[0]
            _id_record = vars.get("id")
            query = db[table_name].id == _id_record
            return dict(db(query).validate_and_update(**vars))
        return dict()

    return locals()